NOTE: To get λ type SHIFT + CTRL + u followed by 03bb.


##################################
# page 191: Type Matching
# 

Match the function to its type signature.

1. Functions:

a) not    # 2c)
b) length # 2d)
c) concat # 2b)
d) head   # 2a)
e) (<)    # 2e)


2. Type signatures:

a) _ :: [a] -> a                # 1d)
b) _ :: [[a]] -> [a]            # 1c)
c) _ :: Bool -> Bool            # 1a)
d) _ :: [a] -> Int              # 1b)
e) _ :: Ord a => a -> a -> Bool # 1e)


##################################
# page 205: Type Arguments
# 

Given a function and its type, tell us what type results from applying some or all of the arguments.

1. If the type of f is a -> a -> a -> a, and the type of 𝑥 is Char then the type of f x is 

a) Char -> Char -> Char # Ans: a)
b) x -> x -> x -> x
c) a -> a -> a
d) a -> a -> a -> Char


2. If the type of g is a -> b -> c -> b, then the type of g 0 'c' "woot" is

a) String
b) Char -> String
c) Int
d) Char           # Ans: d)


3. If the type of h is (Num a, Num b) => a -> b -> b, then the type of h 1.0 2 is:

a) Double
b) Integer         
c) Integral b => b 
d) Num b => b      # Ans: d)


Note that because the type variables 𝑎 and 𝑏 are diﬀerent, the compiler must assume that the types could be diﬀerent. 


4. If the type of h is (Num a, Num b) => a -> b -> b, then the type of h 1 (5.5 :: Double) is

a) Integer
b) Fractional b => b
c) Double            # Ans: c)
d) Num b => b


5. If the type of jackal is (Ord a, Eq b) => a -> b -> a, then the type of jackal "keyboard" "has the word jackal in it"

a) [Char]              # Ans: a)
b) Eq b => b
c) b -> [Char]
d) b
e) Eq b => b -> [Char]


6. If the type of jackal is (Ord a, Eq b) => a -> b -> a, then the type of jackal "keyboard" 

a) b
b) Eq b => b
c) [Char]
d) b -> [Char]
e) Eq b => b -> [Char] # Ans: e)


7. If the type of kessel is (Ord a, Num b) => a -> b -> a, then the type of kessel 1 2 is 

a) Integer
b) Int
c) a
d) (Num a, Ord a) => a # Ans: d)
e) Ord a => a
f) Num a => a


8. If the type of kessel is (Ord a, Num b) => a -> b -> a, then the type of kessel 1 (2 :: Integer) is 

a) (Num a, Ord a) => a # Ans: a)
b) Int
c) a
d) Num a => a
e) Ord a => a
f) Integer


9. If the type of kessel is (Ord a, Num b) => a -> b -> a, then the type of kessel (1 :: Integer) 2 is

a) Num a => a
b) Ord a => a
c) Integer             # Ans: c)
d) (Num a, Ord a) => a
e) a




##################################
# page 213: Parametricity
# 
# see parametricity_p213.hs 

All you can do with a parametrically polymorphic value is pass or not pass it to some other expression. Prove that to yourself with these small demonstrations.

1. Given the type a -> a, which is the type for id, attempt to make a function that terminates successfully that does something other than returning the same value. This is impossible, but you should try it anyway. 

Ans: 

parametricity01 :: 


2. We can get a more comfortable appreciation of parametricity by looking at a -> a -> a. This hypothetical function a -> a -> a has two–and only two–implementa- tions. Write both possible versions of a -> a -> a. After doing so, try to violate the constraints of parametrically polymorphic values we outlined above.

Ans: 

parametricity02_v1 :: a -> a-> a
parametricity02_v1 a0 a1 = a0

parametricity02_v2 :: a -> a-> a
parametricity02_v2 a0 a1 = a1


3. Implement a -> b -> b. How many implementations can it have? Does the behavior change when the types of 𝑎 and 𝑏 change?

Ans: It can only have one implementation where the second typeclass is returned, since there is no methods defined for a parametrically-polymorphic-defined variable a. Moreover, the behavior does change when the types a and b change.

parametricity03 :: a -> b -> b
parametricity03 a0 b0 = b0





##################################
# page 220: Apply Yourself
# 
#  see: applyYourself_pg220.hs

Look at these pairs of functions. One function is unapplied, so the compiler will infer maximally polymorphic type. The second function has been applied to a value, so the inferred type signature may have become concrete, or at least less polymorphic. Figure out how the type would change and why, make a note of what you think the new inferred type would be and then check your work in GHCi.

1. -- Type signature of general function
(++) :: [a] -> [a] -> [a]
-- How might that change when we apply
-- it to the following value?
myConcat x = x ++ " yo"

Ans: -- new type a := Char
λ> :t myConcat
myConcat :: [Char] -> [Char] 


2. -- General function
(*) :: Num a => a -> a -> a
-- Applied to a value
myMult x = (x / 3) * 5

Ans: -- new type is instance-constrained by Fractional
λ> :t myMult 
myMult :: Fractional a => a -> a


3. take :: Int -> [a] -> [a]
myTake x = take x "hey you"

Ans: -- new type a := Char
λ> :t myTake
myTake :: Int -> [Char]


4. (>) :: Ord a => a -> a -> Bool
myCom x = x > (length [1..10])

Ans: -- length forces to constrain the type to Int, and since Int has instance of Ord, then it is not necessary to specify it again in the type-constrain signature.
λ> :myCom
myCom :: Int -> Bool


5. (<) :: Ord a => a -> a -> Bool
myAlph x = x < 'z'

Ans: -- 'z' forces the type to be constrained to Char, and Char has instance of Ord so no further signature details are needed
λ> :t myAlph 
myAlph :: Char -> Bool




##################################
# page 225: Multiple Choice
# 

1. A value of type [a] is

a) a list of alphabetic characters
b) a list of lists
c) a list whose elements are all of some type 𝑎    # Ans: c)
d) a list whose elements are all of diﬀerent types


2. A function of type [[a]] -> [a] could

a) take a list of strings as an argument     # Ans: a)
b) transform a character into a string
c) transform a string into a list of strings
d) take two arguments


3. A function of type [a] -> Int -> a

a) takes one argument
b) returns one element of type 𝑎 from a list # Ans: b)
c) must return an Int value
d) is completely fictional


4. A function of type (a, b) -> a

a) takes a list argument and returns a Char value
b) has zero arguments
c) takes a tuple argument and returns the first value # Ans: c)
d) requires that 𝑎 and 𝑏 be of diﬀerent types


