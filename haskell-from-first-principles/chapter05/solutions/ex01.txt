##################################
# page 191: Type Matching
# 

Match the function to its type signature.

1. Functions:

a) not    # 2c)
b) length # 2d)
c) concat # 2b)
d) head   # 2a)
e) (<)    # 2e)


2. Type signatures:

a) _ :: [a] -> a                # 1d)
b) _ :: [[a]] -> [a]            # 1c)
c) _ :: Bool -> Bool            # 1a)
d) _ :: [a] -> Int              # 1b)
e) _ :: Ord a => a -> a -> Bool # 1e)


##################################
# page 205: Type Arguments
# 

Given a function and its type, tell us what type results from applying some or all of the arguments.

1. If the type of f is a -> a -> a -> a, and the type of 𝑥 is Char then the type of f x is 

a) Char -> Char -> Char # Ans: a)
b) x -> x -> x -> x
c) a -> a -> a
d) a -> a -> a -> Char


2. If the type of g is a -> b -> c -> b, then the type of g 0 'c' "woot" is

a) String
b) Char -> String
c) Int
d) Char           # Ans: d)


3. If the type of h is (Num a, Num b) => a -> b -> b, then the type of h 1.0 2 is:

a) Double
b) Integer         
c) Integral b => b 
d) Num b => b      # Ans: d)


Note that because the type variables 𝑎 and 𝑏 are diﬀerent, the compiler must assume that the types could be diﬀerent. 


4. If the type of h is (Num a, Num b) => a -> b -> b, then the type of h 1 (5.5 :: Double) is

a) Integer
b) Fractional b => b
c) Double            # Ans: c)
d) Num b => b


5. If the type of jackal is (Ord a, Eq b) => a -> b -> a, then the type of jackal "keyboard" "has the word jackal in it"

a) [Char]              # Ans: a)
b) Eq b => b
c) b -> [Char]
d) b
e) Eq b => b -> [Char]


6. If the type of jackal is (Ord a, Eq b) => a -> b -> a, then the type of jackal "keyboard" 

a) b
b) Eq b => b
c) [Char]
d) b -> [Char]
e) Eq b => b -> [Char] # Ans: e)


7. If the type of kessel is (Ord a, Num b) => a -> b -> a, then the type of kessel 1 2 is 

a) Integer
b) Int
c) a
d) (Num a, Ord a) => a # Ans: d)
e) Ord a => a
f) Num a => a


8. If the type of kessel is (Ord a, Num b) => a -> b -> a, then the type of kessel 1 (2 :: Integer) is 

a) (Num a, Ord a) => a # Ans: a)
b) Int
c) a
d) Num a => a
e) Ord a => a
f) Integer


9. If the type of kessel is (Ord a, Num b) => a -> b -> a, then the type of kessel (1 :: Integer) 2 is

a) Num a => a
b) Ord a => a
c) Integer             # Ans: c)
d) (Num a, Ord a) => a
e) a




##################################
# page 213: Parametricity
# 
# see parametricity_p213.hs 

All you can do with a parametrically polymorphic value is pass or not pass it to some other expression. Prove that to yourself with these small demonstrations.

1. Given the type a -> a, which is the type for id, attempt to make a function that terminates successfully that does something other than returning the same value. This is impossible, but you should try it anyway. 

Ans: 

parametricity01 :: 


2. We can get a more comfortable appreciation of parametricity by looking at a -> a -> a. This hypothetical function a -> a -> a has two–and only two–implementa- tions. Write both possible versions of a -> a -> a. After doing so, try to violate the constraints of parametrically polymorphic values we outlined above.

Ans: 

parametricity02_v1 :: a -> a-> a
parametricity02_v1 a0 a1 = a0

parametricity02_v2 :: a -> a-> a
parametricity02_v2 a0 a1 = a1


3. Implement a -> b -> b. How many implementations can it have? Does the behavior change when the types of 𝑎 and 𝑏 change?

Ans: It can only have one implementation where the second typeclass is returned, since there is no methods defined for a parametrically-polymorphic-defined variable a. Moreover, the behavior does change when the types a and b change.

parametricity03 :: a -> b -> b
parametricity03 a0 b0 = b0
